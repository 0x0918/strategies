
> 策略名称

增强版唐奇安通道策略

> 策略作者

程文

> 策略描述

#### 前言
提起唐奇安通道，很多人都会联想到海龟交易法则，这也许是有史以来最成功的交易员培训课程。海龟们用神奇的交易系统赚了成百上千万美元，直到1983年海龟交易法则解密，人们才发现这个神奇的交易系统用的是修正版的唐奇安通道。但时过境迁，现在的市场环境已经发生了很大的变化，这导致唐奇安通道策略变得低效，那么今天我们试着改进，看看增强版的唐奇安通道策略效果如何。

#### 唐奇安通道简介
原始的唐奇安通道（Donchianchannel）规则其实很简单，它先设置一条阻力线和一条支撑线，阻力线由过去N天的最高价的最大值形成；支撑线由过去N天的最低价的最小值形成。

- 唐奇安上阻力线：由过去N天的当日最高价的最大值
- 唐奇安下支撑线：由过去N天的当日最低价的最小值

 ![IMG](https://www.fmz.com/upload/asset/394813f216872a354b87.png) 

如上图中唐奇安通道阻力线和支撑线，在外观上与布林带比较相像，只不过布林带的波动比较灵敏，而唐奇安通道则是直上直下。唐奇安通道可以衡量市场的波动性，一般来说通道宽度越宽，市场的波动就越大，通道宽度越窄，市场的波动性也就越小。

#### 原始策略逻辑
除了具有衡量市场波动率这个功能外，它的主要作用是帮助交易者确定买入和卖出时机。因为唐奇安通道是根据最高价和最低价计算出来的，通道的宽窄又随着价格的变化自动调整，所以大多数时候价格是在通道之内运行，很少突破其上下轨道的。

也就是说，价格并不会随意突破阻力线和支撑线，但如果有效突破，那就预示着大行情可能将会出现。此时交易者可以根据支撑和阻力线，确定买进或卖出的具体时机。比如：当价格向上突破阻力线就买入，当价格跌破支撑线就卖出。

之所以原始策略逻辑在早期的金融市场大行其道，是因为最初的市场和市场参与者不太成熟。现如今散户都已经用上了量化交易，策略的同质性，导致策略低效。所以我们有必要对原始策略逻辑加以改进。

#### 改进后的策略逻辑
我们分别从优化开仓方式和止盈止损这两个方面加以改进。首先是开仓方式，做过突破策略的交易者可能会有体会，行情突破阻力线，本来我们是要做多的，结果刚一入场，价格却急转直下，本来看着是一个很好的机会，最后弄了一个措手不及。

大家想一想假突破究竟是怎么来的，怎么总是那么巧合的发生，就好像庄家顶着自己的账号操纵市场一样。其实这是策略同质化的原因，因为前期高低点是固定的，大家都有目共睹，结果大家都等着价格向上突破时买进，该买的都已经买了，此时买力消失，价格自然而然下跌。另外大户也在盯着这个关键点，他也知道散户会在突破时买进，等散户买完不就可以做空割韭菜了么。

所以为了解决这个问题，我们在支撑线和阻力线分别增加一个系数，这样避免与大多数策略参数一致，造成的同质化现象，导致策略低效。另外我们知道，中国的期货市场总是涨的时候涨的缓，跌的时候跌的急，那么可以对支撑线和阻力线设置不同的系数，让策略更合理的适应当前市场环境。

- 唐奇安上轨：由过去N天的最高价的最大值*上涨系数
- 唐奇安下轨：由过去N天的最低价的最小值*下跌系数
- 唐奇安中轨：(唐奇安上轨 + 唐奇安下轨) / 2

然后是改进止盈止损的方式，原始的唐奇安通道规则是，价格突破阻力线开多单，把止盈止损放在支撑线这个位置；价格跌破支撑线开空单，把止盈止损放在阻力线这个位置。但是这里面有一个问题，假如市场波动率比较大，唐奇安通道上轨与下轨的距离就会加宽，此时就会增加止损的成本和损失一部分浮盈。

- 开多：如果当前无持仓，并且价格突破唐奇安上轨
- 开空：如果当前无持仓，并且价格跌破唐奇安下轨
- 平多：如果当前持多单，并且价格跌破唐奇安中轨
- 平空：如果当前持空单，并且价格突破唐奇安中轨

那么折中的办法是，可以根据唐奇安通道的上轨和下轨，再计算出一条中轨，这样把止盈止损放在中轨的位置，无论是持有多单还是空单，只要价格反向突破中轨及时止盈止损，这样不仅可以减少止损时所付出的成本，同时保护你未平仓的利润免受重大不利价格波动的影响。


#### 编写策略
到目前为止，你应该很好地理解了原始唐奇安通道规则，以及我们将要改进它的方法。现在我们就用代码编写这个交易策略吧。

**第1步：编写策略框架**

策略框架其实就是两个函数，其中main函数是整个程序的入口函数，也就是说策略开始执行的时候，会先执行main函数；另外一个是onTick函数，onTick只是一个函数的名字，当然你也可以自由命名，onTick函数里面主要编写策略逻辑。整个框架其实就是在main函数中重复执行onTick函数。
```
# 策略主函数
def onTick():
    pass


# 程序入口
def main():
    while True:  # 进入无限循环模式
        onTick()  # 执行策略主函数
        Sleep(1000)  # 休眠1秒
```

**第2步：定义全局变量和外部参数**
我们这个策略只需要一个控制虚拟持仓的全局变量，所谓的虚拟持仓指的是理论持仓而非真实持仓，无论开仓还是平仓，我们都假设订单已经完全成交。这么做的目的是简化初学者的入门门槛，在后续的教程中，我将会教大家如何使用真实的实时账户持仓。
```
# 定义全局变量
mp = 0  # 用于控制虚拟持仓

# 外部参数
long_coefficient = 0.999
short_coefficient = 1.001
cycle_length = 55
```

**第3步：处理K线数据**
我们在前面已经定义过，上轨是过去N天的最高价的最大值，下轨是过去N天的最低价的最小值。要想计算这两个值，首先要先获取基础K线数据。但是在使用GetRecords方法获取完基础K线数据之后，先不要慌着计算上轨和下轨，而是先把数据处理一下。

因为我们在计算上轨和下轨的时候需要N个K线，如果K线数量太少就不能计算了，所以要加一个if条件，判断当前K线是否满足我们所需要的数量，如果不满足就直接返回，等待下一次循环。另外我们还需要从K线数组中提取当前最新价格和上根K线的收盘价，最新价格主要用于开平仓，上根K线收盘价主要用于判断开平仓信号。

有的朋友可能会问，为什么不直接使用最新的价格来判断开平仓信号呢？这是因为如果使用最新价格来判断，就可能出现信号反复的问题，同时也为了规避未来函数和偷价这些常见的量化交易问题，所以我们的策略在设计上是：当前K线出信号，下根K线发单。

```
exchange.SetContractType("rb000")  # 订阅期货品种
bar_arr = exchange.GetRecords()  # 获取K线数组
if len(bar_arr) < cycle_length + 1:  # 判断K线数组的长度
    return  # 如果K线长度过小，就直接返回
close_new = bar_arr[len(bar_arr) - 1]['Close']  # 获取最新价格（卖价），用于开平仓
close_last = bar_arr[len(bar_arr) - 2]['Close']  # 上根K线收盘价，用于
```

**第4步：计算上轨、下轨、中轨**
在发明者量化交易软件中，已经内置了talib库中的Highest函数和Lowest函数，所以我们直接调用这两个函数就可以计算上轨和下轨的值。但因为我们是使用上根K线收盘价为基准，来判断它与上轨、下轨、中轨的位置关系来开平仓，所以在计算上轨和下轨之前需要先删除K线数组中的最后一个元素。

```
bar_arr.pop()  # 去掉K线数组最后一个元素，策略是当前K线出信号，下根K线发单，这样可以避免未来函数和偷价
on_line = TA.Highest(bar_arr, cycle_length, 'High') * long_coefficient  # 计算上轨
under_line = TA.Lowest(bar_arr, cycle_length, 'Low') * short_coefficient  # 计算下轨
middle_line = (on_line + under_line) / 2  # 计算中轨
```
**第5步：下单交易**
根据Python的语法规则，要想在函数内使用外部的全局变量，需要在使用这个变量之前，先用global关键字把变量引入。注意下面代码中的注释，真个代码流程是使用if语句，然后根据我们之前定义的策略逻辑来编写。有两个地方需要注意，一个是在下单之前需要先设置下单的类型方向，也就是先调用SetDirection函数。另一个是在下单之后，要把虚拟持仓变量mp重新赋值。
```
global mp # 引入全局变量

if mp == 0:  # 如果当前无持仓
    if close_last > on_line:  # 如果价格大于上轨
        exchange.SetDirection("buy")  # 设置交易方向和类型
        exchange.Buy(close_new, 1)  # 开多单
        mp = 1  # 设置虚拟持仓的值，即有多单
    elif close_last < under_line:  # 如果价格小于下轨
        exchange.SetDirection("sell")  # 设置交易方向和类型
        exchange.Sell(close_new - 1, 1)  # 开空单
        mp = -1  # 设置虚拟持仓的值，即有空单

# 如果持多单，并且价格小于下轨
if mp > 0 and close_last < middle_line:
    exchange.SetDirection("closebuy")  # 设置交易方向和类型
    exchange.Sell(close_new - 1, 1)  # 平多单
    mp = 0  # 设置虚拟持仓的值，即空仓

# 如果持空单，并且价格大于上轨
if mp < 0 and close_last > middle_line:
    exchange.SetDirection("closesell")  # 设置交易方向和类型
    exchange.Buy(close_new, 1)  # 平空单
    mp = 0  # 设置虚拟持仓的值，即空仓
```

#### 结尾
唐奇安通道作为上个世纪20年代的交易方法，已有将近100年的历史了，这个古老的方法之所以至今流传，一定有它独特的道理。但随着市场的转变，我们也要与时俱进而不是贸然使用。随着你对交易认知的提升，你会发现改进的方法非常多。

我想这就是交易的魅力所在，每一位交易者都应该是一位探险者，大胆探索小心求证，长此以往就一定能有适合自己的交易方法。最后配合合理的风险管理，方能成为以为成功的交易者。关于唐奇安通道的用法以及改进后的策略，今天就介绍到这里，更多详情可以关注发明者量化的官方网站。


> 策略参数



|参数|默认值|描述|
|----|----|----|
|long_coefficient|0.999|多头系数|
|short_coefficient|1.001|空头系数|
|cycle_length|55|周期长度|


> 源码 (python)

``` python

# 定义全局变量
mp = 0  												# 用于控制虚拟持仓

def onTick():
    _C(exchange.SetContractType, "rb000")  				# 订阅期货品种
    bar_arr = _C(exchange.GetRecords)  				# 获取K线数组
    if len(bar_arr) < 60:
        return
    close_new = bar_arr[-1]['Close']	# 获取最新价格（卖价）
    close_last = bar_arr[-2]['Close']	# 上根K线收盘价
    bar_arr.pop()									# 删除数组最后一个数据
    # 计算唐奇安上轨
    on_line = TA.Highest(bar_arr, 55, 'High') * 0.999
    # 计算唐奇安下轨
    under_line = TA.Lowest(bar_arr, 55, 'Low') * 1.001
    # 计算唐奇安中轨
    middle_line = (on_line + under_line) / 2
    global mp 								# 引入全局变量
    # 如果持多单，并且价格小于下轨
    if mp > 0 and close_last < middle_line:
        exchange.SetDirection("closebuy")  	# 设置交易方向和类型
        exchange.Sell(close_new - 1, 1)  	# 平多单
        mp = 0  								# 设置虚拟持仓的值，即空仓
    # 如果持空单，并且价格大于上轨
    if mp < 0 and close_last > middle_line:
        exchange.SetDirection("closesell")	# 设置交易方向和类型
        exchange.Buy(close_new, 1)  			# 平空单
        mp = 0  								# 设置虚拟持仓的值，即空仓
    if mp == 0:  							# 如果当前无持仓
        if close_last > on_line:  			# 如果价格大于上轨
            exchange.SetDirection("buy")  	# 设置交易方向和类型
            exchange.Buy(close_new, 1)  		# 开多单
            mp = 1  							# 设置虚拟持仓的值，即有多单
        elif close_last < under_line:  		# 如果价格小于下轨
            exchange.SetDirection("sell")  	# 设置交易方向和类型
            exchange.Sell(close_new - 1, 1) 	# 开空单
            mp = -1  							# 设置虚拟持仓的值，即有空单
        
# 程序入口      
def main():
    while True:								# 进入无线循环模式
        onTick()								# 执行策略主函数
        Sleep(1000)  							# 休眠1秒
```

> 策略出处

https://www.fmz.com/strategy/176458

> 更新时间

2021-11-11 09:54:42
